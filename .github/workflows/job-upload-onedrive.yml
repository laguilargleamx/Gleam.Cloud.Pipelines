name: Job Build and Upload Flutter App

on: 
  workflow_call:
    inputs:
      project:
        required: true
        type: string
      apk_name:
        required: true
        type: string
      apk_path:
        required: true
        type: string
      env_name:
        required: true
        type: string
      build_type:
        required: true
        type: string
      env_file:
        required: true
        type: string
    secrets:
      azure_client_id:
        required: true
      azure_client_secret:
        required: true
      azure_tenant_id:
        required: true
      onedrive_folder_id:
        required: true
      android_keystore_base64:
        required: true
      android_keystore_password:
        required: true
      android_key_password:
        required: true
      android_key_alias:
        required: true
      google_services_json_base65:
        required: true
      dev_api_base_url:
        required: false
      dev_system:
        required: false
      dev_permissions:
        required: false
      qa_api_base_url:
        required: false
      qa_system:
        required: false
      qa_permissions:
        required: false
      prod_api_base_url:
        required: false
      prod_system:
        required: false
      prod_permissions:
        required: false

jobs: 
  build-and-upload:
    name: "Build Flutter App and Upload to OneDrive"
    runs-on: ubuntu-22.04
    outputs:
      upload_success: ${{ steps.upload-onedrive.outputs.upload_success }}
      file_url: ${{ steps.upload-onedrive.outputs.file_url }}
      
    steps:
      - uses: actions/checkout@v4

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.32.1'

      - name: Create environment files
        id: create-env
        run: |
          # Determinar el ambiente basado en el branch
          if [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            ENV_FILE=".env.dev"
            ENV_NAME="dev"
            echo "ðŸŒ Ambiente: DEV"
          elif [[ "${{ github.ref }}" == "refs/heads/qa" ]]; then
            ENV_FILE=".env.qa"
            ENV_NAME="qa"
            echo "ðŸŒ Ambiente: QA"
          elif [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            ENV_FILE=".env"
            ENV_NAME="prod"
            echo "ðŸŒ Ambiente: PRODUCCIÃ“N"
          else
            ENV_FILE=".env.dev"
            ENV_NAME="dev"
            echo "ðŸŒ Ambiente: DEV (por defecto)"
          fi
          
          echo "ðŸ“„ Archivo principal: $ENV_FILE"
          echo "ðŸ·ï¸ Nombre del ambiente: $ENV_NAME"
          
          # Crear .env.dev
          cat > .env.dev << 'EOF'
          API_BASE_URL=${{ secrets.dev_api_base_url }}
          SYSTEM=${{ secrets.dev_system }}
          PERMISSIONS=${{ secrets.dev_permissions }}
          EOF
          
          # Crear .env.qa
          cat > .env.qa << 'EOF'
          API_BASE_URL=${{ secrets.qa_api_base_url }}
          SYSTEM=${{ secrets.qa_system }}
          PERMISSIONS=${{ secrets.qa_permissions }}
          RESOURCE_URL=${{ secrets.resource_url }}
          EOF
          
          # Crear .env (producciÃ³n)
          cat > .env << 'EOF'
          API_BASE_URL=${{ secrets.prod_api_base_url }}
          SYSTEM=${{ secrets.prod_system }}
          PERMISSIONS=${{ secrets.prod_permissions }}
          EOF
          
          echo "ðŸ“ Archivos de ambiente creados:"
          echo "   - .env.dev (DEV)"
          echo "   - .env.qa (QA)" 
          echo "   - .env (PRODUCCIÃ“N)"
          
          # Guardar el archivo principal y nombre del ambiente como variables de salida
          echo "ENV_FILE=$ENV_FILE" >> $GITHUB_OUTPUT
          echo "ENV_NAME=$ENV_NAME" >> $GITHUB_OUTPUT

      - name: Verify environment files
        run: |
          echo "ðŸ“ Verificando archivos de ambiente creados:"
          echo ""
          echo "ðŸ” .env.dev (DEV):"
          cat .env.dev
          echo ""
          echo "ðŸ” .env.qa (QA):"
          cat .env.qa
          echo ""
          echo "ðŸ” .env (PRODUCCIÃ“N):"
          cat .env
          echo ""
          echo "ðŸ“‹ Todos los archivos: $(ls -la .env*)"
          echo ""
          echo "ðŸŽ¯ Archivo principal para este ambiente: ${{ steps.create-env.outputs.ENV_FILE }}"

      - name: Install dependencies
        run: flutter pub get

      - name: Run code generation
        run: flutter pub run build_runner build --delete-conflicting-outputs

      - name: Run tests
        run: flutter test

      - name: Setup Android Keystore
        id: setup-keystore
        run: |
          echo "ðŸ” Configurando keystore para firma de Android..."
          
          # Crear directorio para el keystore
          mkdir -p android/app
          
          # Decodificar el keystore desde GitHub Secrets
          echo "${{ secrets.android_keystore_base64 }}" | base64 -d > android/app/keystore.jks
          
          # Verificar que el keystore se creÃ³ correctamente
          if [ -f "android/app/keystore.jks" ]; then
            echo "âœ… Keystore decodificado exitosamente"
            ls -la android/app/keystore.jks
          else
            echo "âŒ Error: No se pudo crear el keystore"
            exit 1
          fi
          
          # Crear archivo key.properties para el build
          cat > android/key.properties << EOF
          storePassword=${{ secrets.android_keystore_password }}
          keyPassword=${{ secrets.android_key_password }}
          keyAlias=${{ secrets.android_key_alias }}
          storeFile=keystore.jks
          EOF
          
          echo "ðŸ“„ Archivo key.properties creado"
          echo "ðŸ”‘ Alias de la clave: ${{ secrets.android_key_alias }}"
          
          # Mostrar el SHA-1 del keystore (opcional, no crÃ­tico)
          echo "ðŸ” Intentando mostrar SHA-1 del keystore:"
          if keytool -list -v -keystore android/app/keystore.jks -alias ${{ secrets.android_key_alias }} -storepass ${{ secrets.android_keystore_password }} 2>/dev/null | grep "SHA1:"; then
            echo "âœ… SHA-1 obtenido correctamente"
          else
            echo "âš ï¸ No se pudo obtener SHA-1 (no crÃ­tico para el build)"
          fi

      - name: Setup Google Services
        run: |
          echo "ðŸ”§ Configurando Google Services..."
          
          # Crear google-services.json desde GitHub Secrets
          echo "${{ secrets.google_services_json_base65 }}" | base64 -d > android/app/google-services.json
          
          # Verificar que el archivo se creÃ³ correctamente
          if [ -f "android/app/google-services.json" ]; then
            echo "âœ… Google Services configurado exitosamente"
            echo "ðŸ“„ Archivo google-services.json creado"
          else
            echo "âŒ Error: No se pudo crear google-services.json"
            exit 1
          fi

      - name: Build APK
        id: build-apk
        run: |
          # Generar timestamp Unix
          TIMESTAMP=$(date +%s)
          echo "ðŸ• Timestamp: $TIMESTAMP"
          
          # Determinar el tipo de build segÃºn la rama
          if [[ "${{ github.ref }}" == "refs/heads/dev" ]] || [[ "${{ github.ref }}" == "refs/heads/qa" ]]; then
            BUILD_TYPE="profile"
            echo "ðŸ”§ Generando APK en modo PROFILE para rama ${{ github.ref_name }}"
          elif [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            BUILD_TYPE="release"
            echo "ðŸš€ Generando APK en modo RELEASE para rama master"
          else
            BUILD_TYPE="profile"
            echo "ðŸ”§ Generando APK en modo PROFILE (por defecto)"
          fi
          
          # Construir el APK con el tipo correspondiente y firma
          flutter build apk --$BUILD_TYPE --dart-define=ENV=${{ steps.create-env.outputs.ENV_FILE }}
          
          # Definir el nombre del APK con versiÃ³n y tipo de build
          APK_NAME="${{ steps.create-env.outputs.ENV_NAME }}_${BUILD_TYPE}_$TIMESTAMP.apk"
          echo "ðŸ“± Nombre del APK: $APK_NAME"
          
          # Renombrar el APK generado
          mv "build/app/outputs/flutter-apk/app-$BUILD_TYPE.apk" "build/app/outputs/flutter-apk/$APK_NAME"
          
          # Guardar el nombre del APK como variable de salida
          echo "APK_NAME=$APK_NAME" >> $GITHUB_OUTPUT
          echo "APK_PATH=build/app/outputs/flutter-apk/$APK_NAME" >> $GITHUB_OUTPUT
          echo "BUILD_TYPE=$BUILD_TYPE" >> $GITHUB_OUTPUT
          
          echo "âœ… APK construido en modo $BUILD_TYPE y renombrado: $APK_NAME"

      - name: Show build summary
        run: |
          echo "ðŸ“‹ RESUMEN DEL BUILD:"
          echo "======================"
          echo "ðŸŒ Ambiente: ${{ steps.create-env.outputs.ENV_NAME }}"
          echo "ðŸ”§ Tipo de build: ${{ steps.build-apk.outputs.BUILD_TYPE }}"
          echo "ðŸ“± Nombre del APK: ${{ steps.build-apk.outputs.APK_NAME }}"
          echo "ðŸ“ Ruta del APK: ${{ steps.build-apk.outputs.APK_PATH }}"
          echo "ðŸ·ï¸ Rama: ${{ github.ref_name }}"
          echo "ðŸ• Timestamp: $(date)"
          echo "======================"

      - name: Upload APK to OneDrive
        id: upload-onedrive
        run: |
          echo "â˜ï¸ Subiendo APK a OneDrive..."
          
          # Obtener access token para Microsoft Graph usando OAuth2
          ACCESS_TOKEN=$(curl -s -X POST \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "client_id=${{ secrets.azure_client_id }}" \
            -d "client_secret=${{ secrets.azure_client_secret }}" \
            -d "scope=https://graph.microsoft.com/.default" \
            -d "grant_type=client_credentials" \
            "https://login.microsoftonline.com/${{ secrets.azure_tenant_id }}/oauth2/v2.0/token" \
            | jq -r '.access_token')
          
          if [ "$ACCESS_TOKEN" = "null" ] || [ -z "$ACCESS_TOKEN" ]; then
            echo "âŒ Error: No se pudo obtener access token"
            exit 1
          fi
          
          echo "âœ… Access token obtenido exitosamente"
          
          # Usar el UPN directamente para OneDrive personal
          echo "ðŸ” Usando UPN para OneDrive..."
          USER_UPN="laguilar@gleam.mx"
          echo "âœ… UPN configurado: $USER_UPN"
          
          # Crear directorio en OneDrive si no existe
          FOLDER_PATH="${{ secrets.onedrive_folder_id }}/${{ steps.create-env.outputs.ENV_NAME }}"
          
          echo "ðŸ“ Creando directorio: $FOLDER_PATH"
          
          # Verificar si el directorio existe usando el UPN
          FOLDER_CHECK=$(curl -s -H "Authorization: Bearer $ACCESS_TOKEN" \
            "https://graph.microsoft.com/v1.0/users/$USER_UPN/drive/root:$FOLDER_PATH" \
            -w "%{http_code}" -o /dev/null)
          
          if [ "$FOLDER_CHECK" != "200" ]; then
            echo "ðŸ“ Creando directorio $FOLDER_PATH..."
            curl -X POST \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"name\":\"${{ steps.create-env.outputs.ENV_NAME }}\",\"folder\":{},\"@microsoft.graph.conflictBehavior\":\"rename\"}" \
              "https://graph.microsoft.com/v1.0/users/$USER_UPN/drive/root:${{ secrets.onedrive_folder_id }}:/children"
          else
            echo "âœ… Directorio ya existe: $FOLDER_PATH"
          fi
          
          # Subir el APK
          echo "ðŸ“¤ Subiendo APK: ${{ steps.build-apk.outputs.APK_NAME }}"
          
          echo "ðŸ” Creando sesiÃ³n de upload..."
          UPLOAD_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"item\":{\"@microsoft.graph.conflictBehavior\":\"rename\",\"name\":\"${{ steps.build-apk.outputs.APK_NAME }}\"}}" \
            "https://graph.microsoft.com/v1.0/users/$USER_UPN/drive/root:$FOLDER_PATH/${{ steps.build-apk.outputs.APK_NAME }}:/createUploadSession")
          
          echo "ðŸ“‹ Respuesta de upload session:"
          echo "$UPLOAD_RESPONSE"
          
          UPLOAD_URL=$(echo "$UPLOAD_RESPONSE" | jq -r '.uploadUrl')
          
          if [ "$UPLOAD_URL" != "null" ] && [ -n "$UPLOAD_URL" ]; then
            echo "âœ… SesiÃ³n de upload creada: $UPLOAD_URL"
            
            # Subir el archivo usando la sesiÃ³n de upload
            echo "ðŸ“¤ Subiendo archivo..."
            
            # Obtener el tamaÃ±o del archivo para validaciÃ³n
            FILE_SIZE=$(stat -c%s "${{ steps.build-apk.outputs.APK_PATH }}" 2>/dev/null || stat -f%z "${{ steps.build-apk.outputs.APK_PATH }}" 2>/dev/null)
            echo "ðŸ“ TamaÃ±o del archivo: $FILE_SIZE bytes"
            
            # Subir el archivo con validaciÃ³n de respuesta
            UPLOAD_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};SIZE:%{size_upload}" -X PUT \
              -H "Content-Type: application/octet-stream" \
              -H "Content-Range: bytes 0-$((FILE_SIZE-1))/$FILE_SIZE" \
              --data-binary @"${{ steps.build-apk.outputs.APK_PATH }}" \
              "$UPLOAD_URL")
            
            # Extraer el cÃ³digo de estado HTTP y el tamaÃ±o subido
            HTTP_STATUS=$(echo "$UPLOAD_RESPONSE" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            UPLOADED_SIZE=$(echo "$UPLOAD_RESPONSE" | grep -o "SIZE:[0-9]*" | cut -d: -f2)
            
            echo "ðŸ“Š CÃ³digo HTTP: $HTTP_STATUS"
            echo "ðŸ“Š TamaÃ±o subido: $UPLOADED_SIZE bytes"
            
            # Validar que la subida fue exitosa
            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
              if [ "$UPLOADED_SIZE" = "$FILE_SIZE" ]; then
                echo "âœ… APK subido exitosamente a OneDrive"
                echo "ðŸ”— UbicaciÃ³n: $FOLDER_PATH/${{ steps.build-apk.outputs.APK_NAME }}"
                echo "upload_success=true" >> $GITHUB_OUTPUT
                echo "file_url=$FOLDER_PATH/${{ steps.build-apk.outputs.APK_NAME }}" >> $GITHUB_OUTPUT
              else
                echo "âŒ Error: Archivo subido parcialmente ($UPLOADED_SIZE/$FILE_SIZE bytes)"
                echo "upload_success=false" >> $GITHUB_OUTPUT
                exit 1
              fi
            else
              echo "âŒ Error: FallÃ³ la subida del archivo (HTTP $HTTP_STATUS)"
              echo "ðŸ“‹ Respuesta: $UPLOAD_RESPONSE"
              echo "upload_success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "âŒ Error: No se pudo crear la sesiÃ³n de upload"
            echo "ðŸ” Respuesta completa: $UPLOAD_RESPONSE"
            echo "upload_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
